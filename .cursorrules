During your interaction with the user, if you find anything reusable in this project (e.g. version of a library, model name), especially about a fix to a mistake you made or a correction you received, you should take note in the `Lessons` section in the `.cursorrules` file so you will not make the same mistake again.

You should also use the `.cursorrules` file as a Scratchpad to organize your thoughts. Especially when you receive a new task, you should first review the content of the Scratchpad, clear old different task if necessary, first explain the task, and plan the steps you need to take to complete the task. You can use todo markers to indicate the progress, e.g.
[X] Task 1
[ ] Task 2

Also update the progress of the task in the Scratchpad when you finish a subtask.
Especially when you finished a milestone, it will help to improve your depth of task accomplishment to use the Scratchpad to reflect and plan.

The goal is to help you maintain a big picture as well as the progress of the task. Always refer to the Scratchpad when you plan the next step.

# PRDs

Always refer to the PRDs to understand the project and mark any tasks done when you finish them.

- [v1.md](prds/v1.md)

# Rust Rules

- Always write idiomatic Rust code.
- Every new function or module must include comprehensive unit tests.
- Use Rust's error handling best practices (Result<T, E>, ? operator, etc.).
- Document all public APIs with comprehensiverustdoc comments (///).
- Maintain a modular design: keep CAIP, DIDComm, TAP core, and WASM bindings separate.
- Use cargo fmt and clippy for formatting and linting.
- Prioritize clear and maintainable code.
- Check off tasks in the project plan file as soon as they are complete.
- Ensure CI/CD integration is updated as features are added.
- Always build the entire project before fixing a task as a compilation error would cause the entire project to fail.
- Always ensure that tests are run before finishing a task
- Aim for 100% test coverage on all modules.
- For WASM components, ensure proper bindings with `wasm-bindgen` and test in a JavaScript environment.
- Provide TypeScript definitions that accurately reflect the WASM APIs.
- When running `cargo doc` please do not use the `--open` flag.

# Typescript Rules

- Always write idiomatic Typescript code.
- Prefer using interfaces and enums over types
- Prefer using pnpm as the package manager
- Every new function or module must include comprehensive unit tests using vitest
- Use Typescript's error handling best practices (Result<T, E>, ? operator, etc.).
- Document all public APIs with comprehensive typedoc comments.
- Remember that any WASM code needs to be compiled from the Rust code in the `tap-didcomm-core` and `tap-didcomm-node` packages.
- Always check you are in the correct directory before running any commands.

# Lessons

## User Specified Lessons
- Always resolve the warnings and errors in the code before starting and completing a task  
- Always run root level tests before starting and completing a task
- When fixing root level failures and warnings do it in this order:
  - `cargo fmt`
  - `cargo clippy`
  - `cargo test`
- Work through each cask in order:
  - `tap-didcomm-core`
  - `tap-didcomm-node`
  - `tap-didcomm-ts`
  - `tap-didcomm-web`
- For the `tap-didcomm-ts` package, always use the `pnpm` command to install dependencies
- For changes in the Rust code, run the `build:wasm` command in the `tap-didcomm-ts` directory to update WASM artifacts
- Always remember that the TypeScript library lives in `tap-didcomm-ts` directory and not in the root - check this when performing any TypeScript-related tasks

## Cursor learned

### Workspace Configuration
- Keep WASM-specific dependencies at the crate level rather than in workspace dependencies
- Handle getrandom dependency at the crate level with appropriate features
- Use separate WASM targets for web and Node.js builds
- Ensure consistent versioning of WASM-related dependencies across crates

### DIDComm Testing
- When implementing mock plugins for DIDComm testing, ensure base64 encoding/decoding is handled correctly
- For mock encryption/decryption, use base64 encoding as a simple test mechanism
- Test both success and error cases for message handling
- Ensure proper error handling in async operations
- Avoid duplicate trait implementations by using derive macros
- Use Arc for thread-safe sharing of mock plugins in tests
- Keep mock implementations simple but functional for testing purposes
- Implement all required traits for mock plugins (DIDResolver, Signer, Encryptor)

### Mock Plugin Implementation
- Use #[async_trait] macro consistently for async trait implementations
- Implement proper error conversion between core and node crates
- Keep mock implementations stateless when possible
- Use base64 encoding/decoding for simple mock cryptographic operations
- Return meaningful test data that can be validated
- Include comprehensive test cases for each mock implementation

### Test Organization
- Group tests logically by functionality
- Test both success and error paths
- Use descriptive test names that indicate what is being tested
- Include setup and teardown code where needed
- Mock external dependencies appropriately
- Test edge cases and boundary conditions
- Ensure test isolation and independence

### Error Handling
- Implement proper error conversion between crates
- Use thiserror for deriving error implementations
- Ensure error messages are descriptive and helpful
- Handle all possible error cases in mock implementations
- Test error conditions explicitly
- Propagate errors appropriately using the ? operator
- Test error handling in async operations

### TypeScript Configuration
- Always use type-only imports for types when verbatimModuleSyntax is enabled
- Handle undefined error objects safely with optional chaining and nullish coalescing
- Ensure proper error handling in async/await operations
- Use proper TypeScript types for Uint8Array data in crypto operations
- Keep WASM-specific types separate from core types
- Implement proper error handling for all async operations
- Use proper TypeScript configuration for WASM integration

### Current Task Progress
[X] Fix mock plugin implementation
[X] Update TypeScript configuration
[X] Fix linter errors in plugins.ts
[X] Fix linter errors in custom-resolver.ts
[X] Fix linter errors in custom-crypto.ts
[X] Fix linter errors in node example
[X] Verify type checking passes
[ ] Run tests to ensure everything works correctly

### Next Steps
1. Run the test suite to verify all changes
2. Fix any remaining test failures
3. Document the changes made
4. Update the build process if needed

# Scratchpad

## Current Task: Fix tap-didcomm-web Package

### Overview
Working on fixing issues in the tap-didcomm-web package, which provides a web server interface for DIDComm operations.

### Progress Tracking
[ ] Review and fix any dependency issues in Cargo.toml
[ ] Fix any compilation errors in the web server implementation
[ ] Ensure proper integration with tap-didcomm-core and tap-didcomm-node
[ ] Verify all tests are passing
[ ] Update documentation if needed

### Current State
- tap-didcomm-core and tap-didcomm-node crates are working
- Need to focus on tap-didcomm-web fixes
- Will maintain existing functionality while fixing issues

### Next Steps
1. Check current compilation status of tap-didcomm-web
2. Address any dependency mismatches
3. Fix compilation errors
4. Run and verify tests
5. Document any changes made

### Notes
- Keep focus only on tap-didcomm-web
- Ensure compatibility with working core and node crates
- Follow Rust best practices for web server implementation
- Maintain proper error handling and logging

# Lessons

## Rust Package
- Keep WASM-specific dependencies at the crate level
- Handle getrandom dependency at the crate level with appropriate features
- Use separate WASM targets for web and Node.js builds
- Ensure consistent versioning of dependencies across crates

## DIDComm Testing
- When implementing mock plugins for DIDComm testing, ensure base64 encoding/decoding is handled correctly
- For mock encryption/decryption, use base64 encoding as a simple test mechanism
- Test both success and error cases for message handling
- Ensure proper error handling in async operations

## Error Handling
- Implement proper error conversion between crates
- Use thiserror for deriving error implementations
- Ensure error messages are descriptive and helpful
- Handle all possible error cases in mock implementations
- Test error conditions explicitly


