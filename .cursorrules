During your interaction with the user, if you find anything reusable in this project (e.g. version of a library, model name), especially about a fix to a mistake you made or a correction you received, you should take note in the `Lessons` section in the `.cursorrules` file so you will not make the same mistake again.

You should also use the `.cursorrules` file as a Scratchpad to organize your thoughts. Especially when you receive a new task, you should first review the content of the Scratchpad, clear old different task if necessary, first explain the task, and plan the steps you need to take to complete the task. You can use todo markers to indicate the progress, e.g.
[X] Task 1
[ ] Task 2

Also update the progress of the task in the Scratchpad when you finish a subtask.
Especially when you finished a milestone, it will help to improve your depth of task accomplishment to use the Scratchpad to reflect and plan.

The goal is to help you maintain a big picture as well as the progress of the task. Always refer to the Scratchpad when you plan the next step.

# PRDs

Always refer to the PRDs to understand the project and mark any tasks done when you finish them.

- [v1.md](prds/v1.md)

# Rust Rules

- Always write idiomatic Rust code.
- Every new function or module must include comprehensive unit tests.
- Use Rust's error handling best practices (Result<T, E>, ? operator, etc.).
- Document all public APIs with comprehensiverustdoc comments (///).
- Maintain a modular design: keep CAIP, DIDComm, TAP core, and WASM bindings separate.
- Use cargo fmt and clippy for formatting and linting.
- Prioritize clear and maintainable code.
- Check off tasks in the project plan file as soon as they are complete.
- Ensure CI/CD integration is updated as features are added.
- Always build the entire project before fixing a task as a compilation error would cause the entire project to fail.
- Always ensure that tests are run before finishing a task
- Aim for 100% test coverage on all modules.
- For WASM components, ensure proper bindings with `wasm-bindgen` and test in a JavaScript environment.
- Provide TypeScript definitions that accurately reflect the WASM APIs.
- When running `cargo doc` please do not use the `--open` flag.

# Typescript Rules

- Always write idiomatic Typescript code.
- Prefer using interfaces and enums over types
- Prefer using pnpm as the package manager
- Every new function or module must include comprehensive unit tests using vitest
- Use Typescript's error handling best practices (Result<T, E>, ? operator, etc.).
- Document all public APIs with comprehensive typedoc comments.
- Remember that any WASM code needs to be compiled from the Rust code in the `tap-didcomm-core` and `tap-didcomm-node` packages.
- Always check you are in the correct directory before running any commands.

# Lessons

## User Specified Lessons
- Always resolve the warnings and errors in the code before starting and completing a task  
- Always run root level tests before starting and completing a task
- When fixing root level failures and warnings do it in this order:
  - `cargo fmt`
  - `cargo clippy`
  - `cargo test`
- Work through each cask in order:
  - `tap-didcomm-core`
  - `tap-didcomm-node`
  - `tap-didcomm-ts`
  - `tap-didcomm-web`
- For the `tap-didcomm-ts` package, always use the `pnpm` command to install dependencies
- For changes in the Rust code, run the `build:wasm` command in the `tap-didcomm-ts` directory to update WASM artifacts

## Cursor learned

### Workspace Configuration
- Keep WASM-specific dependencies at the crate level rather than in workspace dependencies
- Handle getrandom dependency at the crate level with appropriate features
- Use separate WASM targets for web and Node.js builds
- Ensure consistent versioning of WASM-related dependencies across crates

### DIDComm Testing
- When implementing mock plugins for DIDComm testing, ensure base64 encoding/decoding is handled correctly
- For mock encryption/decryption, use base64 encoding as a simple test mechanism
- Test both success and error cases for message handling
- Ensure proper error handling in async operations
- Avoid duplicate trait implementations by using derive macros
- Use Arc for thread-safe sharing of mock plugins in tests
- Keep mock implementations simple but functional for testing purposes
- Implement all required traits for mock plugins (DIDResolver, Signer, Encryptor)

### Mock Plugin Implementation
- Use #[async_trait] macro consistently for async trait implementations
- Implement proper error conversion between core and node crates
- Keep mock implementations stateless when possible
- Use base64 encoding/decoding for simple mock cryptographic operations
- Return meaningful test data that can be validated
- Include comprehensive test cases for each mock implementation

### Test Organization
- Group tests logically by functionality
- Test both success and error paths
- Use descriptive test names that indicate what is being tested
- Include setup and teardown code where needed
- Mock external dependencies appropriately
- Test edge cases and boundary conditions
- Ensure test isolation and independence

### Error Handling
- Implement proper error conversion between crates
- Use thiserror for deriving error implementations
- Ensure error messages are descriptive and helpful
- Handle all possible error cases in mock implementations
- Propagate errors appropriately using the ? operator
- Test error conditions explicitly

### JWE Implementation
- Support both X25519 and NIST curves (P-256, P-384, P-521) for ECDH key agreement
- Ensure proper key derivation using HKDF with appropriate info strings
- Implement proper key wrapping and unwrapping
- Handle all supported content encryption algorithms
- Test roundtrip encryption/decryption with all supported curves
- Validate all base64url-encoded fields
- Implement proper error handling for invalid key material

# Scratchpad

## Current Task: Build and Test tap-didcomm-node

### Overview
Moving on to the tap-didcomm-node crate after completing tap-didcomm-core fixes. Need to ensure all builds and tests are passing.

### Progress Tracking
[X] Run initial build and test to identify issues
  [X] Run cargo fmt
  [ ] Run cargo clippy
  [ ] Run cargo test
[ ] Review and fix any compilation errors
  [ ] Fix mock plugin implementation
  [ ] Fix node module errors
  [ ] Fix actor system errors
[ ] Review and fix any clippy warnings
[ ] Review and fix any test failures
[ ] Verify WASM build functionality
  [ ] Check wasm-bindgen configuration
  [ ] Verify Node.js specific features
  [ ] Test WASM exports

### Current Issues Identified
1. Mock plugin implementation has incorrect trait implementation
2. Private module access issues from tap-didcomm-core
3. Missing Node module implementation
4. Actor system needs proper error handling
5. WASM bindings need to be verified

### Next Steps
1. Fix mock plugin implementation to match core traits
2. Update dependencies and module access
3. Implement proper Node module
4. Fix actor system implementation
5. Verify WASM integration

### Notes
- Need to ensure compatibility with tap-didcomm-core changes
- Watch for any async trait implementations that might need updating
- Verify error handling between core and node crates
- Check mock implementations for Node.js specific features


