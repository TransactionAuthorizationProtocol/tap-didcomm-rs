During your interaction with the user, if you find anything reusable in this project (e.g. version of a library, model name), especially about a fix to a mistake you made or a correction you received, you should take note in the `Lessons` section in the `.cursorrules` file so you will not make the same mistake again.

You should also use the `.cursorrules` file as a Scratchpad to organize your thoughts. Especially when you receive a new task, you should first review the content of the Scratchpad, clear old different task if necessary, first explain the task, and plan the steps you need to take to complete the task. You can use todo markers to indicate the progress, e.g.
[X] Task 1
[ ] Task 2

Also update the progress of the task in the Scratchpad when you finish a subtask.
Especially when you finished a milestone, it will help to improve your depth of task accomplishment to use the Scratchpad to reflect and plan.

The goal is to help you maintain a big picture as well as the progress of the task. Always refer to the Scratchpad when you plan the next step.

# PRDs

Always refer to the PRDs to understand the project and mark any tasks done when you finish them.

- [v1.md](prds/v1.md)

# Rust Rules

## Build and Test Workflow
1. Always run the following commands in sequence before AND after making code changes:
   - `cargo fmt` - Format all code
   - `cargo clippy` - Check for lints and common mistakes
   - `cargo build` - Ensure everything compiles
   - `cargo test` - Run all tests

2. Work through crates in the following sequence:
   - `tap-didcomm-core` - Core functionality first
   - `tap-didcomm-node` - Node.js bindings second
   - `tap-didcomm-web` - Web bindings third
   - `tap-didcomm-ts` - TypeScript integration last

3. For TypeScript changes:
   - After Rust changes, run `pnpm build:wasm` in `tap-didcomm-ts`
   - Run `pnpm test` to verify TypeScript integration

## Code Quality
- Always write idiomatic Rust code
- Every new function or module must include comprehensive unit tests
- Use Rust's error handling best practices (Result<T, E>, ? operator, etc.)
- Document all public APIs with comprehensive rustdoc comments (///)
- Maintain a modular design: keep CAIP, DIDComm, TAP core, and WASM bindings separate
- Prioritize clear and maintainable code
- Check off tasks in the project plan file as soon as they are complete

## Testing
- Aim for 100% test coverage on all modules
- Test both success and error cases
- Include integration tests between crates
- Test WASM bindings in both Node.js and browser environments
- Verify TypeScript type definitions match Rust APIs

## WASM Considerations
- Keep WASM-specific dependencies at the crate level
- Use separate WASM targets for web and Node.js builds
- Ensure proper error handling across language boundaries
- Test WASM bindings in both Node.js and browser contexts
- Provide accurate TypeScript definitions

## Documentation
- Document all public APIs with comprehensive rustdoc comments
- Include examples in documentation
- Document WASM usage in TypeScript
- Keep README files up to date
- When running `cargo doc` do not use the `--open` flag

## Error Handling
- Use thiserror for deriving error implementations
- Ensure descriptive error messages
- Handle all error cases explicitly
- Test error conditions
- Properly convert errors across language boundaries

## Dependencies
- Keep dependencies up to date
- Minimize dependency footprint
- Use consistent versions across crates
- Handle WASM-specific dependencies appropriately
- Document dependency requirements

## CI/CD
- Ensure CI/CD integration is updated as features are added
- All tests must pass before merging
- Maintain consistent formatting
- Address all clippy warnings
- Build documentation in CI

## Security
- Follow cryptographic best practices
- Handle sensitive data appropriately
- Use secure random number generation
- Validate all inputs
- Test security-critical code thoroughly

# Typescript Rules

- Always write idiomatic Typescript code.
- Prefer using interfaces and enums over types
- Prefer using pnpm as the package manager
- Every new function or module must include comprehensive unit tests using vitest
- Use Typescript's error handling best practices (Result<T, E>, ? operator, etc.).
- Document all public APIs with comprehensive typedoc comments.
- Remember that any WASM code needs to be compiled from the Rust code in the `tap-didcomm-core` and `tap-didcomm-node` packages.
- Always check you are in the correct directory before running any commands.

# Lessons

## User Specified Lessons
- Always resolve the warnings and errors in the code before starting and completing a task  
- Always run root level tests before starting and completing a task
- When fixing root level failures and warnings do it in this order:
  - `cargo fmt`
  - `cargo clippy`
  - `cargo test`
- Work through each cask in order:
  - `tap-didcomm-core`
  - `tap-didcomm-node`
  - `tap-didcomm-ts`
  - `tap-didcomm-web`
- For the `tap-didcomm-ts` package, always use the `pnpm` command to install dependencies
- For changes in the Rust code, run the `build:wasm` command in the `tap-didcomm-ts` directory to update WASM artifacts
- Always remember that the TypeScript library lives in `tap-didcomm-ts` directory and not in the root - check this when performing any TypeScript-related tasks

## Cursor learned

### Workspace Configuration
- Keep WASM-specific dependencies at the crate level rather than in workspace dependencies
- Handle getrandom dependency at the crate level with appropriate features
- Use separate WASM targets for web and Node.js builds
- Ensure consistent versioning of WASM-related dependencies across crates

### DIDComm Testing
- When implementing mock plugins for DIDComm testing, ensure base64 encoding/decoding is handled correctly
- For mock encryption/decryption, use base64 encoding as a simple test mechanism
- Test both success and error cases for message handling
- Ensure proper error handling in async operations
- Avoid duplicate trait implementations by using derive macros
- Use Arc for thread-safe sharing of mock plugins in tests
- Keep mock implementations simple but functional for testing purposes
- Implement all required traits for mock plugins (DIDResolver, Signer, Encryptor)

### Mock Plugin Implementation
- Use #[async_trait] macro consistently for async trait implementations
- Implement proper error conversion between core and node crates
- Keep mock implementations stateless when possible
- Use base64 encoding/decoding for simple mock cryptographic operations
- Return meaningful test data that can be validated
- Include comprehensive test cases for each mock implementation

### Test Organization
- Group tests logically by functionality
- Test both success and error paths
- Use descriptive test names that indicate what is being tested
- Include setup and teardown code where needed
- Mock external dependencies appropriately
- Test edge cases and boundary conditions
- Ensure test isolation and independence

### Error Handling
- Implement proper error conversion between crates
- Use thiserror for deriving error implementations
- Ensure error messages are descriptive and helpful
- Handle all possible error cases in mock implementations
- Test error conditions explicitly
- Propagate errors appropriately using the ? operator
- Test error handling in async operations

### TypeScript Configuration
- Always use type-only imports for types when verbatimModuleSyntax is enabled
- Handle undefined error objects safely with optional chaining and nullish coalescing
- Ensure proper error handling in async/await operations
- Use proper TypeScript types for Uint8Array data in crypto operations
- Keep WASM-specific types separate from core types
- Implement proper error handling for all async operations
- Use proper TypeScript configuration for WASM integration

### Current Task Progress
[X] Fix mock plugin implementation
[X] Update TypeScript configuration
[X] Fix linter errors in plugins.ts
[X] Fix linter errors in custom-resolver.ts
[X] Fix linter errors in custom-crypto.ts
[X] Fix linter errors in node example
[X] Verify type checking passes
[ ] Run tests to ensure everything works correctly

### Next Steps
1. Run the test suite to verify all changes
2. Fix any remaining test failures
3. Document the changes made
4. Update the build process if needed

# Scratchpad

## Current Task: Fix Cryptographic API Usage

### Overview
Need to fix EphemeralSecret API usage and validate all crypto operations.

### Progress Tracking
[X] Review current implementation
[X] Fix AES-KW key handling with GenericArray
[X] Fix HMAC trait ambiguity
[X] Update EphemeralSecret API usage
[X] Fix duplicate test names
[X] Fix trait implementations
[X] Add missing implementations
[ ] Run formatting and tests
[ ] Fix any remaining issues

### Strategy
- Check latest API docs for EphemeralSecret
- Import required traits
- Update method calls
- Run cargo fmt, clippy, and test

### Notes
- Fixed JweError trait conflicts
- Added proper EphemeralPublicKey implementation
- Fixed DIDResolver trait implementation
- Added utils module with DID validation
- Fixed MockTestPlugin implementation

## Current Task: Fix Ownership/Move Errors in pack.rs

### Overview
Need to fix ownership issues in pack.rs by properly handling references and clones for recipient and other moved values.

### Progress Tracking
[X] Review current implementation
[X] Fix pattern matching to use references
[X] Add explicit clones where needed
[X] Add missing imports and traits
[X] Create missing modules and types
[ ] Verify changes compile
[ ] Run tests

### Strategy
- Use `if let Some(ref recipient)` instead of moving values
- Add explicit clones where data needs to be used multiple times
- Keep original data intact for subsequent operations

### Notes
- Fixed conflicting trait implementations in JweError
- Created missing modules and types
- Added proper trait implementations
- Organized module structure

## Current Task: Update JweError enum

### Overview
Need to add missing error variants to JweError enum to support all error cases from algorithms and header modules.

### Progress Tracking
[X] Review current JweError implementation
[X] Identify missing variants
[X] Add new variants with proper documentation
[X] Ensure proper error conversion implementations
[X] Verify changes compile

### Notes
- Added all missing variants with documentation
- Implemented From trait for serde_json::Error
- Used descriptive error messages

## Current Task: Fix tap-didcomm-web Package

### Overview
Working on fixing issues in the tap-didcomm-web package, which provides a web server interface for DIDComm operations.

### Progress Tracking
[ ] Review and fix any dependency issues in Cargo.toml
[ ] Fix any compilation errors in the web server implementation
[ ] Ensure proper integration with tap-didcomm-core and tap-didcomm-node
[ ] Verify all tests are passing
[ ] Update documentation if needed

### Current State
- tap-didcomm-core and tap-didcomm-node crates are working
- Need to focus on tap-didcomm-web fixes
- Will maintain existing functionality while fixing issues

### Next Steps
1. Check current compilation status of tap-didcomm-web
2. Address any dependency mismatches
3. Fix compilation errors
4. Run and verify tests
5. Document any changes made

### Notes
- Keep focus only on tap-didcomm-web
- Ensure compatibility with working core and node crates
- Follow Rust best practices for web server implementation
- Maintain proper error handling and logging

# Lessons

## Rust Package
- Keep WASM-specific dependencies at the crate level
- Handle getrandom dependency at the crate level with appropriate features
- Use separate WASM targets for web and Node.js builds
- Ensure consistent versioning of dependencies across crates

## DIDComm Testing
- When implementing mock plugins for DIDComm testing, ensure base64 encoding/decoding is handled correctly
- For mock encryption/decryption, use base64 encoding as a simple test mechanism
- Test both success and error cases for message handling
- Ensure proper error handling in async operations

## Error Handling
- Implement proper error conversion between crates
- Use thiserror for deriving error implementations
- Ensure error messages are descriptive and helpful
- Handle all possible error cases in mock implementations
- Test error conditions explicitly


