Great! I’ll create a detailed PRD for the `tap-didcomm-ts` package that wraps `tap-didcomm-core` and `tap-didcomm-node` in an idiomatic TypeScript API. This will include:

- A plugin system for external DID resolvers and signing/encryption callbacks.
- Dynamic WASM loading for browsers while ensuring compatibility with Node.js.
- Comprehensive testing with `Vitest` or `Jest`, ensuring the actual WASM module is used instead of mocking.
- Modern best practices for WASM inclusion, building, and bundling.

I’ll provide a structured PRD in Markdown with single-point tasks marked as checkboxes for easy tracking.

# Product Requirements Document: **tap-didcomm-ts**

## Objective & Scope

**tap-didcomm-ts** is a TypeScript library that provides an idiomatic TS API for DIDComm (Decentralized Identifier Communication) functionalities. It serves as a high-level wrapper around the Rust-based DIDComm core logic, which is compiled to WebAssembly. In particular, it wraps two WASM modules: `tap-didcomm-core` and `tap-didcomm-node`. By leveraging the robust Rust implementation of DIDComm ([didcomm-node - npm](https://www.npmjs.com/package/didcomm-node#:~:text=Under%20the%20hood)), this library exposes encryption, decryption, signing, and verification features in a way that feels natural to JavaScript/TypeScript developers. 

The scope of this project includes creating a unified API that works in both Node.js and browser environments, handling the loading of the WASM modules appropriately, and providing extensibility through plugins. We will not re-implement cryptographic primitives or DIDComm protocols from scratch – instead, the focus is on integration, API design, and developer experience. All underlying cryptographic and DIDComm message handling is delegated to the Rust WASM code, ensuring consistency with the DIDComm v2 specifications and strong security, while our TypeScript code will manage WASM initialization, environment differences, and plugin hooks.

## Features & Requirements

- **Wrapper Around Rust WASM Modules:** The library must incorporate the functionality of the `tap-didcomm-core` and `tap-didcomm-node` modules. These modules contain the core DIDComm v2 logic implemented in Rust and compiled to WebAssembly. The TypeScript wrapper will load the appropriate module depending on the runtime environment and expose the core functions. The goal is to make usage of DIDComm features seamless – developers should not have to interact with low-level WASM APIs. For example, where the Rust/WASM might expose functions like `pack_encrypted` or `unpack`, the TS wrapper can provide simplified methods (e.g., `encrypt()` and `decrypt()`) with proper typing and error handling.

- **Node.js and Browser Support:** `tap-didcomm-ts` must run in both Node.js and web browser contexts without code changes by the user. This means detecting the environment and ensuring compatibility. In Node.js, the library can use the Node-specific WASM build (`tap-didcomm-node`), whereas in browsers it will use `tap-didcomm-core`. The API exposed to users should remain the same across environments. For instance, a developer can call `tapDidComm.encrypt(message, options)` in either environment and get the same outcome. Environment differences (like how WASM is loaded or how networking is handled) should be abstracted internally.

- **Dynamic WASM Loading in Browsers:** Implement on-demand loading of the WASM module in browser contexts. Instead of bundling a large WASM binary directly into the main bundle, the library should fetch or import it asynchronously. This could be achieved via dynamic `import()` or by using the WASM-bindgen initialization helper that fetches the `.wasm` file. The loading should be **transparent** to the developer using the library, aside from an initial async call if necessary (e.g., an `initialize()` method or making the first use of the API return a Promise). In Node.js, where file access is straightforward, the WASM can be loaded via `require` or file I/O synchronously if needed – but in a browser, an asynchronous fetch is required. The solution must ensure that bundlers (Webpack, Vite, etc.) know how to include the WASM asset or where to load it from. For example, using the `"browser"` field in **package.json** or conditional exports can signal bundlers to use a browser-friendly module that calls `fetch` to retrieve the `.wasm` file ([Recommendations when publishing a Wasm library](https://nickb.dev/blog/recommendations-when-publishing-a-wasm-library/#:~:text=In%20addition%20to%20initializing%20the,the%20Wasm%20from%20a%20URL)). This dynamic loading should degrade gracefully (provide useful errors if the WASM fails to load) and not block the main thread unnecessarily.

- **Encryption, Decryption, Signing, Verification APIs:** Expose high-level functions for core DIDComm cryptographic operations:
  - **Encryption:** Ability to encrypt a plaintext message for one or more recipients (DIDComm "pack_encrypted"). This should handle anonymous encryption (anoncrypt) and authenticated encryption with sender authentication (authcrypt) as supported by the core. The API might look like `encrypt(message, { to: recipientDID, from: senderDID, sign: true/false, ... })` or separate methods for different cases. It should return a properly formatted DIDComm message (likely as a JSON object or string) that can be transported over the network.
  - **Decryption:** Ability to decrypt an encrypted DIDComm message (DIDComm "unpack"). For a given encrypted payload, the library should return the plaintext message and metadata (such as verification results). For example, `decrypt(encryptedMessage)` should return an object containing the message content and info on whether it was authenticated or anonymous, the sender’s DID (if available), etc.
  - **Signing:** Ability to sign a plaintext message without encryption (DIDComm "pack_signed" to create a JWM/JWS). This will produce a message with a signature that can be verified by recipients. API could be `sign(message, { from: senderDID })` resulting in a signed message object or JWT/JWM string.
  - **Verification:** Ability to verify a signed message’s signature. This might be part of the `decrypt`/`unpack` process automatically (as DIDComm unpack will verify signatures if present ([didcomm-node - npm](https://www.npmjs.com/package/didcomm-node#:~:text=,processing%20on%20the%20application%20level)) ([didcomm-node - npm](https://www.npmjs.com/package/didcomm-node#:~:text=const%20,))), but we may also expose a standalone `verify(signedMessage)` for convenience in cases where a message is signed but not encrypted.
  
  These APIs should handle necessary internal calls to the WASM. Input types (message formats, DID identifiers, options) should be developer-friendly (strings or objects, not raw WASM data structures). The output should similarly be easy to consume (e.g., returning JavaScript objects representing the DIDComm message or result, rather than WASM-specific types).

- **Plugin System for Extensibility:** The library will implement a plugin mechanism to allow external code to interface with DIDComm operations. This is crucial for flexibility, as different environments or applications may need custom ways to resolve DIDs or handle keys. The plugin system should mirror the design of the Rust core’s plugin architecture (as in the `plugin.rs`), ensuring that our wrapper can accommodate the same extensions as the Rust library.
  - *External DID Resolvers:* Allow the consumer of `tap-didcomm-ts` to provide a custom DID resolution function. For example, a developer could register a function `resolveDID(did: string) => Promise<DIDDocument>` with the library. When the DIDComm core needs to resolve a DID (to find encryption keys or verify signatures), the wrapper will invoke this callback and supply the returned DID Document to the Rust logic. This is analogous to implementing the DIDResolver trait in the Rust library, but exposed to JS. If no custom resolver is provided, the library may fall back to a default (which could be a simple stub that fails, or perhaps a default to DID resolution via well-known endpoints if applicable). By supporting an injected resolver, we ensure developers can integrate with various DID methods and networks (e.g., resolving did:ion, did:key, did:web, etc., through external APIs). **Note:** This follows the DIDComm design which expects the host application to supply DID resolution ([didcomm-node - npm](https://www.npmjs.com/package/didcomm-node#:~:text=,internally%20Base58%20only%29%20formats)).
  - *Signer & Encryptor Callbacks:* Similarly, provide hooks for custom cryptographic operations. A **signer plugin** would be a callback like `sign(data: Uint8Array, keyId: string) => Promise<Uint8Array>` that the library calls to produce a digital signature when needed. An **encryptor plugin** might be `encrypt(data: Uint8Array, encryptionKey: string) => Promise<Uint8Array>` (or a more complex interface if needed for multi-recipient encryption). These callbacks are useful when the actual cryptographic keys are managed outside the WASM (for example, in a hardware security module, or using the WebCrypto API, or a cloud KMS). If provided, the library will use these callbacks instead of the default Rust-implemented signing/encryption for certain operations. For instance, when packing a message that needs to be signed with the sender’s private key, if a signer plugin is registered, the WASM might call out to JS (through our wrapper) to get the signature. The TypeScript wrapper must handle bridging the Rust code to the JS callback (possibly by using wasm-bindgen's ability to call imported JS functions). This feature ensures that `tap-didcomm-ts` can be used in high-security contexts where keys never leave a secure store. It should match the Rust implementation's expectations so that the overall DIDComm protocols still execute correctly.

- **Network Requests via Fetch:** All network operations performed by the library should use the **Fetch API**. In practice, the core DIDComm operations themselves might not perform HTTP calls (they focus on packing/unpacking messages), but some plugin callbacks or utility functions might need to fetch data (for example, a DID resolver plugin might call an HTTP DID resolution service, or the library might support sending a message via HTTP to a DID service endpoint). The requirement is to standardize on `fetch()` for these cases to maximize cross-platform compatibility. Using `fetch` means browser environments use their built-in implementation, and Node.js (especially v18+ which includes fetch globally) can use the same API ([Recommendations when publishing a Wasm library](https://nickb.dev/blog/recommendations-when-publishing-a-wasm-library/#:~:text=In%20addition%20to%20initializing%20the,the%20Wasm%20from%20a%20URL)). We should avoid Node-only libraries like `http`/`https` or Axios for internal calls. If targeting Node versions that lack fetch, we may include a lightweight polyfill or instruct developers to polyfill if needed. By relying on fetch, we ensure that any **HTTP(s) requests** (for DID document discovery, mediator service calls, etc.) work uniformly in different environments.

- **Idiomatic TypeScript API (Typings & Documentation):** The library should feel like a native TypeScript API. This means:
  - Every public function, method, or class has precise type definitions. Use TypeScript interfaces and types to represent domain concepts: e.g., define a `DIDDocument` type (with the expected DID Doc structure), types for messages (perhaps `PackedMessage`, `PlaintextMessage`), and option bags (e.g., `EncryptOptions`, `SignOptions`).
  - Leverage modern TS features for clarity, such as **generics** or **enums** where appropriate (for example, an enum for message packing algorithm types, if needed).
  - Include **TSDoc** comments for all public APIs. Document the purpose of each method, the meaning of its parameters, and the format of its return value. Also document any important assumptions (for instance, if `encrypt` requires that the DID resolvers have the recipient's public key preloaded).
  - Ensure the package provides its own `.d.ts` type declarations (either by being written in TS or providing a declaration file) so that consumers get autocomplete and compile-time type checking out of the box.
  - Align with naming conventions familiar to JS/TS developers. For instance, use camelCase for function names, and perhaps use classes or namespaces to group functionality logically (e.g., a `DidComm` class with static methods, or an exported singleton instance, etc.). Avoid exposing raw or verbose WASM-generated function names if they are not user-friendly.
  - Provide examples in documentation (like a README snippet) to demonstrate how to use the API. This will also serve as a guide to ensure the API design is ergonomic.

- **Comprehensive Testing (Vitest/Jest):** Develop a thorough suite of tests to validate all features. The tests should be written in TypeScript/JavaScript using a framework like **Vitest** (preferred for Vite projects) or **Jest**, and should run as part of continuous integration.
  - **WASM Execution in Tests:** The tests must invoke the actual WebAssembly functions – *no mocking of the DIDComm core*. For example, to test encryption and decryption, the test should call `encrypt()` to produce a ciphertext, then call `decrypt()` on that result and assert that the original plaintext is recovered. This ensures our wrapper truly works and the integration with WASM is correct.
  - **Node and Browser Coverage:** We should test in a Node environment and in a browser-like environment. For Node, this can be as simple as running the tests in NodeJS (the library should detect Node and use `tap-didcomm-node`). For browser, we can use a headless browser or a simulated environment (such as running the tests in jsdom, or using Vitest's ability to simulate a browser DOM environment). The key is to verify that our dynamic loading logic and any browser-specific code paths work as expected. For example, a test can simulate a browser by setting `global.fetch` and ensuring `tap-didcomm-core` is loaded.
  - **Plugin Tests:** Write tests for the plugin system. For instance, provide a dummy DID resolver function via the plugin API and test that when encrypting to a DID, the resolver was called (perhaps by having it set a flag or return a known DID Document and verifying the outcome). Similarly, test that a signer callback is invoked when signing a message. If possible, also test error paths (what happens if the resolver fails or returns an invalid document).
  - **Edge Cases:** Include tests for invalid inputs or edge cases (e.g., attempting to decrypt with a wrong key, or trying to encrypt with an unsupported algorithm) to ensure the library surfaces errors from the core gracefully.
  - Use test assertions to confirm that the outputs of the WASM (ciphertexts, signatures, etc.) have the expected structure (for instance, DIDComm encrypted messages are JSON with `ciphertext` and `protected` fields, etc.). We might use known test vectors or cross-verify with the Rust core if possible.

- **WASM Build & Bundling Best Practices:** The implementation must follow modern best practices for building and packaging a WASM-powered library:
  - **Including WASM in NPM Package:** Ensure the compiled `.wasm` files from `tap-didcomm-core`/`tap-didcomm-node` are included in the published package. The package structure might include these in a `dist/` or `pkg/` folder. Use the `files` field in package.json or an .npmignore to include the necessary artifacts.
  - **Conditional Exports / Entry Points:** Use Node vs Browser specific entry points. For example, the package could have an `"exports"` field where `"import"` and `"require"` (or `"node"` and `"browser"`) point to different bundles. The Node entry might import `tap-didcomm-node.js` (the glue code for Node WASM) and the browser entry imports `tap-didcomm-core.js`. This way, bundlers automatically pick the right version. Alternatively, use the legacy `"browser"` field to specify an alternative file for bundlers.
  - **WASM Loading Method:** For the browser build, decide whether to embed the WASM binary or load it externally. **Inline (base64) embedding** simplifies usage (no separate fetch), but increases bundle size and has a performance cost for decoding ([Recommendations when publishing a Wasm library](https://nickb.dev/blog/recommendations-when-publishing-a-wasm-library/#:~:text=One%20cost%20is%20file%20size,a%20Wasm%20project%20of%20mine)) ([Recommendations when publishing a Wasm library](https://nickb.dev/blog/recommendations-when-publishing-a-wasm-library/#:~:text=var%20src%20%3D%20,i%5D%20%3D%20raw.charCodeAt%28i%29%3B)). **External loading** keeps bundles slim but requires the WASM file to be fetched or preloaded. A hybrid approach could be used: embed for smaller WASM or allow opting out. Given DIDComm crypto might produce a moderately sized WASM, leaning towards external loading with a nice API (and possibly a default built-in URL) is preferable for performance. Provide an option for the user to manually initialize with a custom WASM URL or binary if they have special hosting needs (following the principle of allowing initialization customization ([Recommendations when publishing a Wasm library](https://nickb.dev/blog/recommendations-when-publishing-a-wasm-library/#:~:text=The%20base64%20approach%20won%E2%80%99t%20be,library%20to%20additional%20use%20cases))).
  - **Build Tools:** Use a bundler (like Rollup or esbuild) or the TypeScript compiler configuration that is WASM-aware. For instance, if using Rollup, include a plugin to import .wasm files either as base64 or copy them to the output directory. Ensure source maps are generated for ease of debugging the TS code.
  - **Testing the Package:** Before finalizing, test that the packaged library (as it would be published) can be installed and used in a sample Node project and a sample web project (for example, a simple React/Vite app). This acts as an end-to-end verification that all bundling settings are correct and the developer experience is smooth.
  - **Documentation of WASM Handling:** Document in the README how the WASM is handled (e.g., “this library will fetch a WASM file at runtime” or “the WASM is embedded”). While this is not a code feature, it's a requirement for transparency to users who might need to know, for example, if an extra network request happens on library init.

By meeting these features and requirements, `tap-didcomm-ts` will offer a robust, secure, and developer-friendly interface for DIDComm operations, bridging the gap between high-performance Rust code and the flexibility of JavaScript/TypeScript.

## Implementation Tasks

Below is a breakdown of implementation tasks. Each task is listed as a checkbox for tracking progress – the implementing developer (or coding agent) should check off each item as it is completed:

- [ ] **Project Setup:** Initialize the TypeScript project structure for **tap-didcomm-ts**. Create a `package.json` with appropriate metadata (name, version, etc.) and include dependencies or peer dependencies for `tap-didcomm-core` and `tap-didcomm-node` (the WASM modules). Set up a build system (using tsc, Rollup, or another bundler) that can output both Node and browser versions. Include configuration files like `tsconfig.json`. Ensure the source code directory is prepared (e.g., `src/index.ts` as an entry point).

- [ ] **Environment Detection & WASM Initialization:** Implement logic to load the correct WASM module based on the environment:
  - In the Node.js context, load the WASM packaged for Node. This might involve calling `require('tap-didcomm-node')` or importing a Node-specific initialization function. Confirm that in Node, the WASM can be loaded (Node often allows sync loading via file system read under the hood in the wasm-bindgen generated code).
  - In the browser context, use dynamic import or an async initialization function to load `tap-didcomm-core`. For example, use `import('tap-didcomm-core')` (if it returns a promise resolving when WASM is ready) or call an initialization function provided by that module (commonly, wasm-bindgen packages export an async `init()` that fetches the .wasm).
  - Abstract this into a single **initialization routine** in our TS wrapper. E.g., `async function initTapDidComm(): Promise<void>` that internally sets up the WASM. This function should be called (explicitly by the user or implicitly on first API call). Document if the user needs to call an init function or if the library manages it.
  - Verify this detection by simulating both environments during development (e.g., run a small Node script to ensure it picks Node module, and open a test HTML file or use jest/jsdom to ensure the browser path works).
  - **Completion Criteria:** The library can successfully load the WASM module in both environments without errors, and a basic call (like a version query or a no-op function from WASM) succeeds.

- [ ] **Expose Cryptographic APIs (encrypt, decrypt, sign, verify):** Create TypeScript functions or a class interface that wraps the core DIDComm functionalities:
  - Design a `DidComm` class or similar namespace. For instance, a class `DidCommClient` with methods `encrypt()`, `decrypt()`, `sign()`, `verify()`, or static functions in a module.
  - For **encrypt**: Implement a method that takes a plaintext message (could be a string or an object to be JSON-stringified) and an options object (containing `to` recipient DID, optional `from` sender DID, and flags or parameters like `protectSenderIdentity` or `signBeforeEncrypt`). Internally, this should call the WASM's pack_encrypted (or equivalent) function. Handle conversion of inputs to the format the WASM expects (e.g., converting JS strings to Uint8Arrays if needed, or assembling a DIDComm message object if the core expects structured input).
  - For **decrypt**: Implement a method that takes an encrypted DIDComm message (likely as a JSON object or string) and calls the WASM unpack function. It should return the decrypted plaintext and any metadata (e.g., who it was from, whether the signature was verified, etc.). Define a return type for this (e.g., `{ message: object, metadata: DecryptMetadata }`).
  - For **sign**: Implement a method to produce a signed message without encryption. This may call a WASM function for packing signed messages. Ensure it attaches the signature correctly and returns a message that can be verified.
  - For **verify**: If not implicitly covered by `decrypt`, implement a method to verify a signed message. This might call a WASM verify function or simply attempt an unpack in a verify-only mode. It should return a boolean or metadata about the validity of the signature.
  - Add input validation: e.g., throw informative errors if required fields are missing in options (like `to` in encrypt).
  - **Completion Criteria:** These functions are defined in the TS module, with proper types. They don't need to be fully functional (wired to WASM) until later tasks, but their signatures and basic structure should be in place. Documentation comments should be added describing each function’s use.

- [ ] **Implement Plugin System – DID Resolver:** Define an interface (e.g., `IDidResolver`) or function type for DID resolution: for example, `type DidResolverFn = (did: string) => Promise<DIDDocument>`. In the library, provide a method or property to register a custom resolver. For instance, `DidComm.setDidResolver(resolverFn: DidResolverFn): void`.
  - Internally, if the WASM core requires DID resolution, determine how to bridge it. If the Rust WASM accepts a callback for DID resolution via wasm-bindgen, you'll need to provide a JS function to WASM. More likely, the pattern will be: before calling an encrypt or verify function, the TS wrapper will use the registered resolver to get the DID Doc and then pass that data into the WASM function call (many DIDComm implementations have you pass the DID Doc as part of the pack/unpack call).
  - Implement logic so that when `encrypt()` (or others) is called, if a DID resolver is set and the operation needs to resolve a DID (e.g., to get recipient keys), the resolver function is awaited and its result is transformed into whatever structure the WASM expects (possibly a JSON string or JS object that wasm-bindgen can convert).
  - Ensure that the resolver can handle multiple calls (e.g., encryption might need to resolve each recipient DID, and decryption might need to resolve the sender's DID for authenticity).
  - Add error handling: if the resolver fails (rejects) or returns an invalid document, surface this error appropriately (perhaps reject the encrypt promise with a clear message).
  - Write a simple unit test (or at least a debug test) where you register a resolver that returns a known DID Document (maybe a dummy with an embedded public key), and verify that the encrypt function calls this resolver (you can instrument the resolver to set a flag or count calls).
  - **Completion Criteria:** The library can accept a DID resolver plugin and use it during operations. This should be demonstrable via a test or example (even if the actual encryption isn't fully working yet, you should be able to show the resolver was invoked with the correct DID string).

- [ ] **Implement Plugin System – Signer & Encryptor Callbacks:** Extend the plugin system to support external signing and encryption:
  - Define interfaces or function types for the signer and encryptor. For example: 
    ```ts
    type SignerFn = (data: Uint8Array, senderDid: string) => Promise<Uint8Array>;
    type EncryptorFn = (plaintext: Uint8Array, recipientDid: string) => Promise<{ ciphertext: Uint8Array, metadata: any }>;
    ```
    (The exact signature may differ based on how the core works; adjust as needed, including perhaps passing algorithm types or key references.)
  - Provide methods to register these: e.g., `DidComm.setSigner(signerFn)` and `DidComm.setEncryptor(encryptorFn)`.
  - If the underlying WASM supports injecting these (maybe via imported JS functions), set that up during initialization. If not, plan for the TS wrapper to call these before/after core calls. For instance, if doing a signed message: the TS wrapper could ask the signer plugin to produce a signature and then feed that into a WASM function that attaches it, or perhaps bypass the WASM signing and assemble the signed message in TS if easier.
  - For encryption, an external encryptor might actually not be needed if DIDComm encryption is fully handled by Rust. However, it could be relevant if wanting to use a custom ECDH or a hardware key for content encryption. If the use case is unclear, make this plugin available for future-proofing, but focus on the signer (signer is definitely useful for not exposing private keys to WASM).
  - Ensure that if these plugins are not set, the WASM's internal crypto is used by default. The library should decide at runtime: if a signer plugin is present and an operation requires signing, use the plugin; otherwise call WASM's signing function (which probably needs the secret from SecretsResolver).
  - The **SecretsResolver** concept from Rust (managing private keys) might overlap with these callbacks. Possibly, instead of a low-level signer function, we might implement a **SecretsResolver plugin** that the WASM calls to fetch a private key by ID, and then WASM does signing. However, handing raw private keys to WASM might be undesirable. If `tap-didcomm-core` expects a secrets resolver (like the SICPA DIDComm library does), our TS can implement a secrets resolver that either pulls keys from memory or, if a custom signer is set, uses a dummy key and then intercepts the signing call. This part may require carefully reading how the WASM expects to get keys or signatures. We ensure our design covers either approach.
  - **Completion Criteria:** The library can register a signer callback that is invoked when needed. At minimum, provide a way to plug it in and illustrate (in tests or docs) how a custom signer (like one that uses `crypto.subtle` WebCrypto) could be used. This task is complete when the mechanism for external signing is proven to work (even if it's a simple dummy signature for testing purposes).

- [ ] **Integrate Fetch for Network Operations:** Go through the code paths (especially DID resolver plugins or any future message sending functions) and ensure `fetch` is used for HTTP calls. For example, if our default DID resolver (in absence of a user plugin) is implemented, it might use `fetch` to retrieve a DID document from a DID URL or DID registry. Implement a simple default DID resolver that demonstrates this (for instance, resolving `did:web` by constructing an HTTPS URL, or a stub for `did:example`). Make sure to handle fetch responses and errors (e.g., throw if non-200, etc.).
  - If Node.js doesn't have `global.fetch` (in Node <18), decide how to handle it: possibly import `node-fetch` as a dev dependency for tests or instruct users to polyfill. Since Node 18+ has fetch, and our target environments likely include modern Node, it's acceptable to assume its presence, but document this requirement.
  - There might not be many places needing fetch in the core functionality aside from DID resolution or maybe mediator HTTP transport which is out of scope. So this task is mostly about ensuring any such usage is via fetch and tested.
  - **Completion Criteria:** Any sample or test that performs a network fetch (perhaps a test that tries to resolve a DID via a known public DID resolver endpoint) should work in both Node and browser contexts. The code should have no direct calls to Node-only HTTP libraries.

- [ ] **Finalize TypeScript Types & Documentation:** After implementing the above features, refine the TypeScript types and add documentation comments:
  - Review all public interfaces (function signatures, option objects, return types) and make sure they are precise and clear. For example, ensure we have a `DIDDocument` interface that matches at least the fields needed (keys, verification methods, etc.), so that users know what to return in their resolver.
  - Add **JSDoc/TSDoc** comments above each public function and class. Describe what the function does, the meaning of parameters (using the `@param` tag), and what it returns (`@returns` tag). Also note any exceptions or errors that might be thrown, and link to external specs if helpful (like "implements DIDComm v2 pack_encrypted").
  - Generate or verify the TypeScript declaration files (.d.ts) if not working in pure TS (but since we'll write in TS, just ensure the compiler produces definitions).
  - Ensure that internal or auxiliary types are marked `export` if they might be useful for users (e.g., export the `DIDDocument` type so someone implementing a resolver can import it for type-checking).
  - **Completion Criteria:** No `any` types remain in the public API. The code is self-documented through type definitions and comments. Editors should show tooltips/documentation for the functions when using the library. At least one pass of reviewing the type definitions for consistency with DIDComm spec (for example, correct field names like `kid`, `alg` in JWK, etc., if those appear).

- [ ] **Testing in Node Environment (Vitest/Jest):** Create a test suite focusing on Node.js usage:
  - Write tests for **encryption -> decryption**: e.g., create a plaintext message, call `encrypt` with a known recipient DID and a known key (which you have to set up via the DID resolver and secrets). Then take the result and call `decrypt`, expecting to get the original plaintext. This may require setting up the test with a dummy DID Document for the recipient that includes a public key, and a corresponding secret (private key) for the sender or recipient in a "secrets resolver" or via the signer plugin. Use keys for a supported curve (e.g., Ed25519 or X25519) possibly hard-coded for test.
  - Write tests for **sign -> verify**: e.g., call `sign` on a plaintext, then either call `verify` or `decrypt` if it was then encrypted, to ensure the signature is recognized. If using the DID resolver and secrets, make sure the public key of the signer is in the DID Document provided so verification can succeed.
  - Test **DID resolver plugin**: register a custom resolver that handles a dummy DID (like "did:example:test") by returning a predetermined DID Document (with keys matching the above). Ensure that when encrypting to "did:example:test", the resolver was called (you can have the resolver function set a variable or use a spy in the tests). Also test the scenario where no resolver is set and encryption to an unknown DID throws an error.
  - Test **signer plugin**: instead of providing the private key via secrets to the WASM, register a signer callback that uses a known key to produce a signature. For example, have the signer plugin use Node crypto or a library to sign a given payload, and ensure that when calling `encrypt` or `sign`, our plugin was invoked. Verify the signature is valid by subsequently decrypting/unpacking via the WASM (which uses the public key in DID Doc).
  - Cover edge cases like attempting to decrypt with wrong keys: for instance, if the DID Document provided doesn't match the key used to encrypt, the decrypt should fail (assert that an error or false verification is returned).
  - Run the test suite in Node and ensure all tests pass. This confirms that our Node integration (using `tap-didcomm-node` WASM) is correct.
  - **Completion Criteria:** A comprehensive set of tests runs successfully in Node. The tests prove that the major features (encrypt, decrypt, sign, verify, DID resolver plugin, signer plugin) work as intended. Code coverage should ideally be high for the core modules.

- [ ] **Testing in Browser Environment:** Set up a way to run tests in a browser or simulated browser:
  - Leverage a test runner that can launch a headless browser (e.g., Karma + Jasmine/Mocha, or use Jest with jsdom if actual cryptography can run in jsdom – note that WebCrypto might not be available in jsdom, so using a real browser might be better for realistic testing of crypto). Vitest can run with jsdom environment; we should try that for simplicity.
  - Repeat critical tests from the Node suite in the browser context. For example, test encrypt/decrypt in the browser. You can reuse the same test vectors (same DID Document and keys). The differences will be in how the WASM is loaded (ensuring that the `tap-didcomm-core` path was taken). If using Vitest, you might configure one set of tests to run with `jsdom` environment, which simulates a browser. Ensure that `global.fetch` is available (Vitest's jsdom should have fetch since it's Node 18 environment, or polyfill if needed).
  - Specifically, test that the dynamic loading works: e.g., call the init or first encrypt and ensure it resolves properly. If possible, verify that the WASM binary was actually fetched (this might be visible in network logs if using a real browser; in jsdom, you might intercept fetch).
  - Test the DID resolver and signer plugins again in this context to ensure no assumptions were made that break in a browser (like using Node Buffer or other Node-only APIs in those code paths).
  - **Manual testing:** In addition to automated tests, if feasible, create a small demo HTML page that uses the built `tap-didcomm-ts` (via a script bundle) to perform an encrypt/decrypt with console logs. Open it in a browser to verify everything works in a real scenario. This can catch any bundling or path issues.
  - **Completion Criteria:** The library passes tests in a browser setting. We have confidence that a web application can include `tap-didcomm-ts` and perform DIDComm operations successfully.

- [ ] **Build & Packaging Verification:** Finalize the build and ensure that the NPM package content is correct:
  - Run the build process to produce output files. There might be a UMD bundle, an ESM bundle, and the .wasm files. Verify that the package includes the `.wasm` file(s) needed and that the paths coded in the library to load them (if any) are correct. For example, if the `tap-didcomm-core` expects the WASM to be at `package/dist/tap_didcomm_core_bg.wasm`, ensure our package structure matches that when published.
  - Double-check **package.json** fields: `main` (for Node, maybe pointing to a CJS bundle), `module` (for ESM bundlers), `browser` (for browser override if used), and `types` (pointing to the .d.ts file). Use the `"exports"` field if using Node's modern package resolution, providing entries for `"node"` and `"default"` or `"import"`.
  - Ensure license and README are included as needed. Although not part of the code, it's part of a quality release.
  - After packaging, test installation by doing `npm pack` (to create a tarball) and then installing that tarball in a fresh project (perhaps as part of CI or a local test) to simulate a user installing from NPM.
  - **Completion Criteria:** The package is ready for publication: it contains all necessary files, and a consumer can import it in both Node and browser contexts without additional configuration. The WASM is correctly found/loaded, and the type definitions are available. Essentially, we've achieved a "dry run" of publishing and using the package.

- [ ] **Documentation & Examples:** Prepare developer-facing documentation:
  - Write a **README.md** (or update it if one exists) for the project that describes what `tap-didcomm-ts` is, how to install it, and basic usage examples. Include code snippets for common tasks: setting up the library (e.g., if an init is needed), encrypting and decrypting a message, using a DID resolver plugin (show a quick example of resolving a DID), and using a signer plugin. This helps users (and also validates that our API is user-friendly).
  - Optionally, generate more detailed API documentation using a tool like TypeDoc, and include it or host it if this is intended for external developers.
  - Make sure the README mentions any important details about environment (e.g., "works in Node 16+ and modern browsers, Node 18+ recommended for built-in fetch support") and about the current status (if some DIDComm features are not fully implemented, though presumably we target full support).
  - **Completion Criteria:** The project has a clear README with usage instructions and examples. The tone and content should make it easy for a new developer to get started with `tap-didcomm-ts` and understand the capabilities. The existence of this documentation also double-checks that our implementation covers the expected use cases.

Each of these tasks should be ticked off once completed, ensuring that all requirements from this PRD are fulfilled. By following this task list, the implementer will cover all necessary aspects of building the `tap-didcomm-ts` library to a high standard of quality and usability. 

